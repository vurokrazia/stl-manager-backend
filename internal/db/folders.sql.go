// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: folders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addFolderCategory = `-- name: AddFolderCategory :exec
INSERT INTO folders_categories (folder_id, category_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddFolderCategoryParams struct {
	FolderID   pgtype.UUID `json:"folder_id"`
	CategoryID pgtype.UUID `json:"category_id"`
}

func (q *Queries) AddFolderCategory(ctx context.Context, arg AddFolderCategoryParams) error {
	_, err := q.db.Exec(ctx, addFolderCategory, arg.FolderID, arg.CategoryID)
	return err
}

const bulkAddFolderCategories = `-- name: BulkAddFolderCategories :exec
INSERT INTO folders_categories (folder_id, category_id)
SELECT UNNEST($1::uuid[]), UNNEST($2::uuid[])
ON CONFLICT DO NOTHING
`

type BulkAddFolderCategoriesParams struct {
	FolderIds   []pgtype.UUID `json:"folder_ids"`
	CategoryIds []pgtype.UUID `json:"category_ids"`
}

func (q *Queries) BulkAddFolderCategories(ctx context.Context, arg BulkAddFolderCategoriesParams) error {
	_, err := q.db.Exec(ctx, bulkAddFolderCategories, arg.FolderIds, arg.CategoryIds)
	return err
}

const bulkRemoveFolderCategories = `-- name: BulkRemoveFolderCategories :exec
DELETE FROM folders_categories WHERE folder_id = ANY($1::uuid[])
`

func (q *Queries) BulkRemoveFolderCategories(ctx context.Context, folderIds []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, bulkRemoveFolderCategories, folderIds)
	return err
}

const countFolderFiles = `-- name: CountFolderFiles :one
SELECT COUNT(*) FROM files
WHERE folder_id = $1
`

func (q *Queries) CountFolderFiles(ctx context.Context, folderID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countFolderFiles, folderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFolders = `-- name: CountFolders :one
SELECT COUNT(*) FROM folders
`

func (q *Queries) CountFolders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countFolders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRootFolders = `-- name: CountRootFolders :one
SELECT COUNT(*) FROM folders
WHERE parent_folder_id IS NULL
`

func (q *Queries) CountRootFolders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRootFolders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchFolders = `-- name: CountSearchFolders :one
SELECT COUNT(*) FROM folders
WHERE name ILIKE '%' || $1::text || '%'
`

func (q *Queries) CountSearchFolders(ctx context.Context, search string) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchFolders, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchRootFolders = `-- name: CountSearchRootFolders :one
SELECT COUNT(*) FROM folders
WHERE parent_folder_id IS NULL
  AND name ILIKE '%' || $1::text || '%'
`

func (q *Queries) CountSearchRootFolders(ctx context.Context, search string) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchRootFolders, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSubfolders = `-- name: CountSubfolders :one
SELECT COUNT(*) FROM folders
WHERE parent_folder_id = $1
`

func (q *Queries) CountSubfolders(ctx context.Context, parentFolderID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSubfolders, parentFolderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFolder = `-- name: CreateFolder :one
INSERT INTO folders (name, path)
VALUES ($1, $2)
RETURNING id, name, path, parent_folder_id, created_at, updated_at
`

type CreateFolderParams struct {
	Name string `json:"name"`
	Path string `json:"path"`
}

func (q *Queries) CreateFolder(ctx context.Context, arg CreateFolderParams) (Folder, error) {
	row := q.db.QueryRow(ctx, createFolder, arg.Name, arg.Path)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Path,
		&i.ParentFolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFolderWithParent = `-- name: CreateFolderWithParent :one
INSERT INTO folders (name, path, parent_folder_id)
VALUES ($1, $2, $3)
RETURNING id, name, path, parent_folder_id, created_at, updated_at
`

type CreateFolderWithParentParams struct {
	Name           string      `json:"name"`
	Path           string      `json:"path"`
	ParentFolderID pgtype.UUID `json:"parent_folder_id"`
}

func (q *Queries) CreateFolderWithParent(ctx context.Context, arg CreateFolderWithParentParams) (Folder, error) {
	row := q.db.QueryRow(ctx, createFolderWithParent, arg.Name, arg.Path, arg.ParentFolderID)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Path,
		&i.ParentFolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFolder = `-- name: DeleteFolder :exec
DELETE FROM folders
WHERE id = $1
`

func (q *Queries) DeleteFolder(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFolder, id)
	return err
}

const getFolder = `-- name: GetFolder :one
SELECT id, name, path, parent_folder_id, created_at, updated_at FROM folders
WHERE id = $1
`

func (q *Queries) GetFolder(ctx context.Context, id pgtype.UUID) (Folder, error) {
	row := q.db.QueryRow(ctx, getFolder, id)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Path,
		&i.ParentFolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFolderByPath = `-- name: GetFolderByPath :one
SELECT id, name, path, parent_folder_id, created_at, updated_at FROM folders
WHERE path = $1
`

func (q *Queries) GetFolderByPath(ctx context.Context, path string) (Folder, error) {
	row := q.db.QueryRow(ctx, getFolderByPath, path)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Path,
		&i.ParentFolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFolderCategories = `-- name: GetFolderCategories :many
SELECT c.id, c.name, c.created_at FROM categories c
INNER JOIN folders_categories fc ON c.id = fc.category_id
WHERE fc.folder_id = $1
ORDER BY c.name
`

func (q *Queries) GetFolderCategories(ctx context.Context, folderID pgtype.UUID) ([]Category, error) {
	rows, err := q.db.Query(ctx, getFolderCategories, folderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFolderFiles = `-- name: GetFolderFiles :many
SELECT f.id, f.path, f.file_name, f.type, f.size, f.modified_at, f.sha256, f.folder_id, f.created_at, f.updated_at FROM files f
WHERE f.folder_id = $1
ORDER BY f.file_name
`

func (q *Queries) GetFolderFiles(ctx context.Context, folderID pgtype.UUID) ([]File, error) {
	rows, err := q.db.Query(ctx, getFolderFiles, folderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.FileName,
			&i.Type,
			&i.Size,
			&i.ModifiedAt,
			&i.Sha256,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFolderFilesPaginated = `-- name: GetFolderFilesPaginated :many
SELECT f.id, f.path, f.file_name, f.type, f.size, f.modified_at, f.sha256, f.folder_id, f.created_at, f.updated_at FROM files f
WHERE f.folder_id = $1
ORDER BY f.file_name
LIMIT $2 OFFSET $3
`

type GetFolderFilesPaginatedParams struct {
	FolderID pgtype.UUID `json:"folder_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) GetFolderFilesPaginated(ctx context.Context, arg GetFolderFilesPaginatedParams) ([]File, error) {
	rows, err := q.db.Query(ctx, getFolderFilesPaginated, arg.FolderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.FileName,
			&i.Type,
			&i.Size,
			&i.ModifiedAt,
			&i.Sha256,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFolders = `-- name: ListFolders :many
SELECT id, name, path, parent_folder_id, created_at, updated_at FROM folders
ORDER BY name
`

func (q *Queries) ListFolders(ctx context.Context) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listFolders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Path,
			&i.ParentFolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFoldersPaginated = `-- name: ListFoldersPaginated :many
SELECT id, name, path, parent_folder_id, created_at, updated_at FROM folders
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListFoldersPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListFoldersPaginated(ctx context.Context, arg ListFoldersPaginatedParams) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listFoldersPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Path,
			&i.ParentFolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootFolders = `-- name: ListRootFolders :many
SELECT id, name, path, parent_folder_id, created_at, updated_at FROM folders
WHERE parent_folder_id IS NULL
ORDER BY name
`

func (q *Queries) ListRootFolders(ctx context.Context) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listRootFolders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Path,
			&i.ParentFolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootFoldersPaginated = `-- name: ListRootFoldersPaginated :many
SELECT id, name, path, parent_folder_id, created_at, updated_at FROM folders
WHERE parent_folder_id IS NULL
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListRootFoldersPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListRootFoldersPaginated(ctx context.Context, arg ListRootFoldersPaginatedParams) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listRootFoldersPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Path,
			&i.ParentFolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubfolders = `-- name: ListSubfolders :many
SELECT id, name, path, parent_folder_id, created_at, updated_at FROM folders
WHERE parent_folder_id = $1
ORDER BY name
`

func (q *Queries) ListSubfolders(ctx context.Context, parentFolderID pgtype.UUID) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listSubfolders, parentFolderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Path,
			&i.ParentFolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubfoldersPaginated = `-- name: ListSubfoldersPaginated :many
SELECT id, name, path, parent_folder_id, created_at, updated_at FROM folders
WHERE parent_folder_id = $1
ORDER BY name
LIMIT $2 OFFSET $3
`

type ListSubfoldersPaginatedParams struct {
	ParentFolderID pgtype.UUID `json:"parent_folder_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

func (q *Queries) ListSubfoldersPaginated(ctx context.Context, arg ListSubfoldersPaginatedParams) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listSubfoldersPaginated, arg.ParentFolderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Path,
			&i.ParentFolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFolderCategory = `-- name: RemoveFolderCategory :exec
DELETE FROM folders_categories
WHERE folder_id = $1 AND category_id = $2
`

type RemoveFolderCategoryParams struct {
	FolderID   pgtype.UUID `json:"folder_id"`
	CategoryID pgtype.UUID `json:"category_id"`
}

func (q *Queries) RemoveFolderCategory(ctx context.Context, arg RemoveFolderCategoryParams) error {
	_, err := q.db.Exec(ctx, removeFolderCategory, arg.FolderID, arg.CategoryID)
	return err
}

const searchFoldersPaginated = `-- name: SearchFoldersPaginated :many
SELECT id, name, path, parent_folder_id, created_at, updated_at FROM folders
WHERE name ILIKE '%' || $3::text || '%'
ORDER BY name
LIMIT $1 OFFSET $2
`

type SearchFoldersPaginatedParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Search string `json:"search"`
}

func (q *Queries) SearchFoldersPaginated(ctx context.Context, arg SearchFoldersPaginatedParams) ([]Folder, error) {
	rows, err := q.db.Query(ctx, searchFoldersPaginated, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Path,
			&i.ParentFolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRootFoldersPaginated = `-- name: SearchRootFoldersPaginated :many
SELECT id, name, path, parent_folder_id, created_at, updated_at FROM folders
WHERE parent_folder_id IS NULL
  AND name ILIKE '%' || $3::text || '%'
ORDER BY name
LIMIT $1 OFFSET $2
`

type SearchRootFoldersPaginatedParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Search string `json:"search"`
}

func (q *Queries) SearchRootFoldersPaginated(ctx context.Context, arg SearchRootFoldersPaginatedParams) ([]Folder, error) {
	rows, err := q.db.Query(ctx, searchRootFoldersPaginated, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Path,
			&i.ParentFolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setFolderCategories = `-- name: SetFolderCategories :exec
DELETE FROM folders_categories WHERE folder_id = $1
`

func (q *Queries) SetFolderCategories(ctx context.Context, folderID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, setFolderCategories, folderID)
	return err
}

const updateFileFolderID = `-- name: UpdateFileFolderID :exec
UPDATE files
SET folder_id = $2
WHERE id = $1
`

type UpdateFileFolderIDParams struct {
	ID       pgtype.UUID `json:"id"`
	FolderID pgtype.UUID `json:"folder_id"`
}

func (q *Queries) UpdateFileFolderID(ctx context.Context, arg UpdateFileFolderIDParams) error {
	_, err := q.db.Exec(ctx, updateFileFolderID, arg.ID, arg.FolderID)
	return err
}

const updateFolder = `-- name: UpdateFolder :one
UPDATE folders
SET name = $2, path = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, name, path, parent_folder_id, created_at, updated_at
`

type UpdateFolderParams struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
	Path string      `json:"path"`
}

func (q *Queries) UpdateFolder(ctx context.Context, arg UpdateFolderParams) (Folder, error) {
	row := q.db.QueryRow(ctx, updateFolder, arg.ID, arg.Name, arg.Path)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Path,
		&i.ParentFolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFolderParent = `-- name: UpdateFolderParent :one
UPDATE folders
SET parent_folder_id = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, name, path, parent_folder_id, created_at, updated_at
`

type UpdateFolderParentParams struct {
	ID             pgtype.UUID `json:"id"`
	ParentFolderID pgtype.UUID `json:"parent_folder_id"`
}

func (q *Queries) UpdateFolderParent(ctx context.Context, arg UpdateFolderParentParams) (Folder, error) {
	row := q.db.QueryRow(ctx, updateFolderParent, arg.ID, arg.ParentFolderID)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Path,
		&i.ParentFolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
