// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: files.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countFiles = `-- name: CountFiles :one
SELECT COUNT(*) FROM files
`

func (q *Queries) CountFiles(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countFiles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFilesByType = `-- name: CountFilesByType :one
SELECT COUNT(*) FROM files WHERE type = $1
`

func (q *Queries) CountFilesByType(ctx context.Context, type_ string) (int64, error) {
	row := q.db.QueryRow(ctx, countFilesByType, type_)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRootFiles = `-- name: CountRootFiles :one
SELECT COUNT(*) FROM files WHERE folder_id IS NULL
`

func (q *Queries) CountRootFiles(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRootFiles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (path, file_name, type, size, modified_at, sha256)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, path, file_name, type, size, modified_at, sha256, folder_id, created_at, updated_at
`

type CreateFileParams struct {
	Path       string             `json:"path"`
	FileName   string             `json:"file_name"`
	Type       string             `json:"type"`
	Size       int64              `json:"size"`
	ModifiedAt pgtype.Timestamptz `json:"modified_at"`
	Sha256     pgtype.Text        `json:"sha256"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.Path,
		arg.FileName,
		arg.Type,
		arg.Size,
		arg.ModifiedAt,
		arg.Sha256,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.FileName,
		&i.Type,
		&i.Size,
		&i.ModifiedAt,
		&i.Sha256,
		&i.FolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files WHERE id = $1
`

func (q *Queries) DeleteFile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFile, id)
	return err
}

const getFile = `-- name: GetFile :one
SELECT id, path, file_name, type, size, modified_at, sha256, folder_id, created_at, updated_at FROM files WHERE id = $1 LIMIT 1
`

func (q *Queries) GetFile(ctx context.Context, id pgtype.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.FileName,
		&i.Type,
		&i.Size,
		&i.ModifiedAt,
		&i.Sha256,
		&i.FolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileByPath = `-- name: GetFileByPath :one
SELECT id, path, file_name, type, size, modified_at, sha256, folder_id, created_at, updated_at FROM files WHERE path = $1 LIMIT 1
`

func (q *Queries) GetFileByPath(ctx context.Context, path string) (File, error) {
	row := q.db.QueryRow(ctx, getFileByPath, path)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.FileName,
		&i.Type,
		&i.Size,
		&i.ModifiedAt,
		&i.Sha256,
		&i.FolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllFiles = `-- name: ListAllFiles :many
SELECT id, path, file_name, type, size, modified_at, sha256, folder_id, created_at, updated_at FROM files
ORDER BY file_name ASC
`

func (q *Queries) ListAllFiles(ctx context.Context) ([]File, error) {
	rows, err := q.db.Query(ctx, listAllFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.FileName,
			&i.Type,
			&i.Size,
			&i.ModifiedAt,
			&i.Sha256,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllFilesPaginated = `-- name: ListAllFilesPaginated :many
SELECT id, path, file_name, type, size, modified_at, sha256, folder_id, created_at, updated_at FROM files
ORDER BY file_name ASC
LIMIT $1 OFFSET $2
`

type ListAllFilesPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllFilesPaginated(ctx context.Context, arg ListAllFilesPaginatedParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listAllFilesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.FileName,
			&i.Type,
			&i.Size,
			&i.ModifiedAt,
			&i.Sha256,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFiles = `-- name: ListFiles :many
SELECT id, path, file_name, type, size, modified_at, sha256, folder_id, created_at, updated_at FROM files
ORDER BY file_name ASC
LIMIT $1 OFFSET $2
`

type ListFilesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListFiles(ctx context.Context, arg ListFilesParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listFiles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.FileName,
			&i.Type,
			&i.Size,
			&i.ModifiedAt,
			&i.Sha256,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootFiles = `-- name: ListRootFiles :many
SELECT id, path, file_name, type, size, modified_at, sha256, folder_id, created_at, updated_at FROM files
WHERE folder_id IS NULL
ORDER BY file_name ASC
`

func (q *Queries) ListRootFiles(ctx context.Context) ([]File, error) {
	rows, err := q.db.Query(ctx, listRootFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.FileName,
			&i.Type,
			&i.Size,
			&i.ModifiedAt,
			&i.Sha256,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootFilesPaginated = `-- name: ListRootFilesPaginated :many
SELECT id, path, file_name, type, size, modified_at, sha256, folder_id, created_at, updated_at FROM files
WHERE folder_id IS NULL
ORDER BY file_name ASC
LIMIT $1 OFFSET $2
`

type ListRootFilesPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListRootFilesPaginated(ctx context.Context, arg ListRootFilesPaginatedParams) ([]File, error) {
	rows, err := q.db.Query(ctx, listRootFilesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.FileName,
			&i.Type,
			&i.Size,
			&i.ModifiedAt,
			&i.Sha256,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFiles = `-- name: SearchFiles :many
SELECT
  f.id, f.path, f.file_name, f.type, f.size, f.modified_at, f.sha256, f.folder_id, f.created_at, f.updated_at,
  similarity(f.file_name, $1) as sim
FROM files f
WHERE
  ($1 = '' OR f.file_name % $1 OR f.path % $1)
  AND ($2 = '' OR f.type = $2)
ORDER BY sim DESC, f.file_name ASC
LIMIT $3 OFFSET $4
`

type SearchFilesParams struct {
	Similarity string      `json:"similarity"`
	Column2    interface{} `json:"column_2"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type SearchFilesRow struct {
	ID         pgtype.UUID        `json:"id"`
	Path       string             `json:"path"`
	FileName   string             `json:"file_name"`
	Type       string             `json:"type"`
	Size       int64              `json:"size"`
	ModifiedAt pgtype.Timestamptz `json:"modified_at"`
	Sha256     pgtype.Text        `json:"sha256"`
	FolderID   pgtype.UUID        `json:"folder_id"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	Sim        float32            `json:"sim"`
}

func (q *Queries) SearchFiles(ctx context.Context, arg SearchFilesParams) ([]SearchFilesRow, error) {
	rows, err := q.db.Query(ctx, searchFiles,
		arg.Similarity,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchFilesRow{}
	for rows.Next() {
		var i SearchFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.FileName,
			&i.Type,
			&i.Size,
			&i.ModifiedAt,
			&i.Sha256,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Sim,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFile = `-- name: UpdateFile :one
UPDATE files
SET file_name = $2, type = $3, size = $4, modified_at = $5, sha256 = $6, updated_at = now()
WHERE path = $1
RETURNING id, path, file_name, type, size, modified_at, sha256, folder_id, created_at, updated_at
`

type UpdateFileParams struct {
	Path       string             `json:"path"`
	FileName   string             `json:"file_name"`
	Type       string             `json:"type"`
	Size       int64              `json:"size"`
	ModifiedAt pgtype.Timestamptz `json:"modified_at"`
	Sha256     pgtype.Text        `json:"sha256"`
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, updateFile,
		arg.Path,
		arg.FileName,
		arg.Type,
		arg.Size,
		arg.ModifiedAt,
		arg.Sha256,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.FileName,
		&i.Type,
		&i.Size,
		&i.ModifiedAt,
		&i.Sha256,
		&i.FolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertFile = `-- name: UpsertFile :one
INSERT INTO files (path, file_name, type, size, modified_at, sha256, folder_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (path)
DO UPDATE SET
  file_name = EXCLUDED.file_name,
  type = EXCLUDED.type,
  size = EXCLUDED.size,
  modified_at = EXCLUDED.modified_at,
  sha256 = EXCLUDED.sha256,
  folder_id = EXCLUDED.folder_id,
  updated_at = now()
RETURNING id, path, file_name, type, size, modified_at, sha256, folder_id, created_at, updated_at
`

type UpsertFileParams struct {
	Path       string             `json:"path"`
	FileName   string             `json:"file_name"`
	Type       string             `json:"type"`
	Size       int64              `json:"size"`
	ModifiedAt pgtype.Timestamptz `json:"modified_at"`
	Sha256     pgtype.Text        `json:"sha256"`
	FolderID   pgtype.UUID        `json:"folder_id"`
}

func (q *Queries) UpsertFile(ctx context.Context, arg UpsertFileParams) (File, error) {
	row := q.db.QueryRow(ctx, upsertFile,
		arg.Path,
		arg.FileName,
		arg.Type,
		arg.Size,
		arg.ModifiedAt,
		arg.Sha256,
		arg.FolderID,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.FileName,
		&i.Type,
		&i.Size,
		&i.ModifiedAt,
		&i.Sha256,
		&i.FolderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
