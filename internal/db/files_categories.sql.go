// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: files_categories.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addFileCategory = `-- name: AddFileCategory :exec
INSERT INTO files_categories (file_id, category_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddFileCategoryParams struct {
	FileID     pgtype.UUID `json:"file_id"`
	CategoryID pgtype.UUID `json:"category_id"`
}

func (q *Queries) AddFileCategory(ctx context.Context, arg AddFileCategoryParams) error {
	_, err := q.db.Exec(ctx, addFileCategory, arg.FileID, arg.CategoryID)
	return err
}

const getFileCategories = `-- name: GetFileCategories :many
SELECT c.id, c.name, c.created_at FROM categories c
INNER JOIN files_categories fc ON fc.category_id = c.id
WHERE fc.file_id = $1
ORDER BY c.name ASC
`

func (q *Queries) GetFileCategories(ctx context.Context, fileID pgtype.UUID) ([]Category, error) {
	rows, err := q.db.Query(ctx, getFileCategories, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesByCategory = `-- name: GetFilesByCategory :many
SELECT f.id, f.path, f.file_name, f.type, f.size, f.modified_at, f.sha256, f.folder_id, f.created_at, f.updated_at FROM files f
INNER JOIN files_categories fc ON fc.file_id = f.id
INNER JOIN categories c ON c.id = fc.category_id
WHERE c.name = $1
ORDER BY f.file_name ASC
LIMIT $2 OFFSET $3
`

type GetFilesByCategoryParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetFilesByCategory(ctx context.Context, arg GetFilesByCategoryParams) ([]File, error) {
	rows, err := q.db.Query(ctx, getFilesByCategory, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.FileName,
			&i.Type,
			&i.Size,
			&i.ModifiedAt,
			&i.Sha256,
			&i.FolderID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllFileCategories = `-- name: RemoveAllFileCategories :exec
DELETE FROM files_categories WHERE file_id = $1
`

func (q *Queries) RemoveAllFileCategories(ctx context.Context, fileID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeAllFileCategories, fileID)
	return err
}

const removeFileCategory = `-- name: RemoveFileCategory :exec
DELETE FROM files_categories
WHERE file_id = $1 AND category_id = $2
`

type RemoveFileCategoryParams struct {
	FileID     pgtype.UUID `json:"file_id"`
	CategoryID pgtype.UUID `json:"category_id"`
}

func (q *Queries) RemoveFileCategory(ctx context.Context, arg RemoveFileCategoryParams) error {
	_, err := q.db.Exec(ctx, removeFileCategory, arg.FileID, arg.CategoryID)
	return err
}
